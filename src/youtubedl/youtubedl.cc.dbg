/*
 * YTDL/YTDLH Transport for Audacious
 * Copyright 2016 - by Jim Turner
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions, and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions, and the following disclaimer in the documentation
 *    provided with the distribution.
 *
 * This software is provided "as is" and without any warranty, express or
 * implied. In no event shall the authors be liable for any damages arising from
 * the use of this software.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <libaudcore/audstrings.h>
#include <libaudcore/runtime.h>
#include <libaudcore/i18n.h>
#include <libaudcore/plugin.h>

/* youtube-dl --no-continue --no-playlist --no-cache-dir --no-progress --no-call-home 
    --youtube-skip-dash-manifest --prefer-ffmpeg -q -f mp4 --no-part https://youtu.be/Uyw8v_YUhD8?t=6m43s  
    -o - 2>/dev/null | fauxdacious -D stdin://-.mp4
*/

static const char gio_about[] =
 N_("Youtube-dl Plugin for Audacious\n"
    "Copyright 2016 Jim Turner");

static const char * const ytdl_schemes[] = {"ytdl"};

class YTDLTransport : public TransportPlugin
{
public:
    static constexpr PluginInfo info = {N_("Youtube-DL Plugin"), PACKAGE};

    constexpr YTDLTransport () : TransportPlugin (info, ytdl_schemes) {}

    VFSImpl * fopen (const char * path, const char * mode, String & error);
};

EXPORT YTDLTransport aud_plugin_instance;

class YTDLFile : public VFSImpl
{
public:
    YTDLFile (const char * path);
    ~YTDLFile ();

    struct OpenError {
        String error;
    };

protected:
    int64_t fread (void * ptr, int64_t size, int64_t nmemb);
    int64_t fwrite (const void * buf, int64_t size, int64_t nitems);

    int fseek (int64_t offset, VFSSeekType whence);
    int64_t ftell ();
    bool feof ();

    int ftruncate (int64_t length);
    int64_t fsize ();

    int fflush ();

private:
    int64_t m_pos = 0;                  /* Current position in the stream */
    FILE * m_filehandle = NULL;
    String m_filename;
    bool m_eof = false;
};

VFSImpl * YTDLTransport::fopen (const char * path, const char * mode, String & error)
{
AUDERR("-----------youtubedl:fopen\n");
    return new YTDLFile (path);
}

YTDLFile::YTDLFile (const char * filename)
{
    if (m_filehandle) {
AUDERR("-0: youtube_dl: STREAM ALREADY OPENED!\n");
        return;
}
//https://youtu.be/Uyw8v_YUhD8?t=6m43s
    String youtubedl_Command = aud_get_str("youtubedl", "command");
AUDERR("-1: youtube-dl=%s=\n", (const char *)youtubedl_Command);
    if (! youtubedl_Command[0])
        youtubedl_Command = String ("youtube-dl --no-continue --no-playlist --no-cache-dir --no-progress --no-call-home --youtube-skip-dash-manifest --prefer-ffmpeg -q -f mp4 --no-part");
AUDERR("-2: youtube-dl=%s=\n", (const char *)youtubedl_Command);
    const char * colon = filename ? strrchr (filename, ':') : filename;
    StringBuf pipein = str_printf ("%s %s%s %s", (const char *)youtubedl_Command, "https", colon, " -o - 2>/dev/null");
//    StringBuf pipein = str_printf ("%.*s", "/usr/local/bin/youtube-dl --no-continue --no-playlist --no-cache-dir --no-progress --no-call-home --youtube-skip-dash-manifest --prefer-ffmpeg -q -f mp4 --no-part https://youtu.be/Uyw8v_YUhD8?t=6m43s -o - 2>/dev/null");
//    m_filehandle = popen ("/usr/local/bin/youtube-dl --no-continue --no-playlist --no-cache-dir --no-progress --no-call-home --youtube-skip-dash-manifest --prefer-ffmpeg -q -f mp4 --no-part https://youtu.be/Uyw8v_YUhD8?t=6m43s -o - 2>/dev/null", "r");
AUDERR("-popening(%s)\n", (const char *)pipein);
    m_filehandle = popen ((const char *)pipein, "r");  //see:http://pubs.opengroup.org/onlinepubs/009696799/functions/popen.html
    if (m_filehandle)
        return;

    /* Handle error */;
    AUDERR ("e:Failed to open %s.\n", filename);
    return;
}

YTDLFile::~YTDLFile ()
{
    pclose(m_filehandle);
AUDERR("-youtube_dl: pclosing\n");
    m_filehandle = nullptr;
}

int64_t YTDLFile::fread (void * buf, int64_t size, int64_t nitems)
{
    if (! m_filehandle || size < 1 || nitems < 1)
    {
        AUDERR ("Cannot read from %s: not open for reading.\n", (const char *) m_filename);
        return 0;
    }

    int64_t bitesread = ::fread (buf, size, nitems, m_filehandle);
    if (bitesread > 0)
        m_pos += bitesread;
    return bitesread;
}

int64_t YTDLFile::fwrite (const void * data, int64_t size, int64_t count)
{
    AUDERR ("Writing is not supported.\n");
    return 0;
}

int YTDLFile::fseek (int64_t offset, VFSSeekType whence)
{
    AUDDBG ("Seeking is not supported.\n");
    return -1;
}

int64_t YTDLFile::ftell ()
{
    return m_pos;
}

bool YTDLFile::feof ()
{
    return ::feof (m_filehandle);
}

int YTDLFile::ftruncate (int64_t size)
{
    AUDERR ("Truncating is not supported.\n");
    return -1;
}

int64_t YTDLFile::fsize ()
{
    return -1;
}

int YTDLFile::fflush ()
{
    return ::fflush (m_filehandle);
}
